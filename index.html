<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Treble Clef Note Reading Game</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/vexflow/3.0.9/vexflow-min.js"></script>

<link href="https://fonts.googleapis.com/css2?family=DM+Serif+Display:ital@0;1&family=DM+Mono:wght@300;400;500&display=swap" rel="stylesheet">
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

  :root {
    --bg: #0e0e12;
    --surface: #16161d;
    --surface2: #1e1e28;
    --border: #2a2a38;
    --accent: #c8f564;
    --accent2: #64f5c8;
    --red: #f56464;
    --text: #e8e8f0;
    --muted: #7070a0;
  }

  body {
    background: var(--bg);
    color: var(--text);
    font-family: 'DM Mono', monospace;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 24px;
  }

  body::before {
    content: '';
    position: fixed;
    inset: 0;
    background:
      radial-gradient(ellipse 60% 40% at 20% 10%, rgba(100,245,200,0.06) 0%, transparent 60%),
      radial-gradient(ellipse 50% 60% at 80% 90%, rgba(200,245,100,0.05) 0%, transparent 60%);
    pointer-events: none;
  }

  /* â”€â”€ Screens â”€â”€ */
  .screen { display: none; width: 100%; max-width: 560px; flex-direction: column; align-items: center; }
  .screen.active { display: flex; }

  /* â”€â”€ Header â”€â”€ */
  .page-title {
    font-family: 'DM Serif Display', serif;
    font-size: clamp(2rem, 5vw, 3rem);
    letter-spacing: -0.02em;
    color: var(--text);
    margin-bottom: 6px;
    text-align: center;
  }
  .page-title span { color: var(--accent); }

  .page-sub {
    font-size: 0.7rem;
    color: var(--muted);
    letter-spacing: 0.15em;
    text-transform: uppercase;
    margin-bottom: 36px;
    text-align: center;
  }

  /* â”€â”€ Card â”€â”€ */
  .card {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 20px;
    padding: 36px;
    width: 100%;
    position: relative;
  }
  .card::before {
    content: '';
    position: absolute;
    top: 0; left: 0; right: 0;
    height: 2px;
    border-radius: 20px 20px 0 0;
    background: linear-gradient(90deg, var(--accent), var(--accent2));
    opacity: 0.7;
  }

  /* â”€â”€ Buttons â”€â”€ */
  .btn {
    display: block;
    width: 100%;
    padding: 15px;
    font-family: 'DM Mono', monospace;
    font-size: 0.82rem;
    font-weight: 500;
    letter-spacing: 0.08em;
    text-transform: uppercase;
    border: none;
    border-radius: 10px;
    cursor: pointer;
    transition: opacity 0.2s, transform 0.1s;
  }
  .btn:hover { opacity: 0.85; }
  .btn:active { transform: scale(0.98); }
  .btn:disabled { opacity: 0.35; cursor: default; }

  .btn-primary { background: var(--accent); color: #0e0e12; }
  .btn-secondary {
    background: var(--surface2);
    color: var(--text);
    border: 1px solid var(--border);
  }
  .btn-secondary:hover { border-color: var(--accent); color: var(--accent); opacity: 1; }

  .btn-gap { margin-top: 12px; }

  /* â”€â”€ Home screen â”€â”€ */
  .home-buttons { display: flex; flex-direction: column; gap: 14px; width: 100%; }

  .mode-btn {
    padding: 22px 24px;
    text-align: left;
    display: flex;
    flex-direction: column;
    gap: 5px;
  }
  .mode-btn .btn-title {
    font-size: 1rem;
    font-weight: 500;
    letter-spacing: 0.04em;
    color: #0e0e12;
  }
  .mode-btn .btn-desc {
    font-size: 0.68rem;
    letter-spacing: 0.06em;
    color: rgba(14,14,18,0.6);
    text-transform: none;
  }

  /* â”€â”€ Level select â”€â”€ */
  .level-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; width: 100%; }

  .level-card {
    background: var(--surface2);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 20px 16px;
    cursor: pointer;
    transition: border-color 0.2s, transform 0.1s;
    text-align: center;
  }
  .level-card:hover { border-color: var(--accent); transform: translateY(-2px); }
  .level-card:active { transform: scale(0.97); }

  .level-num {
    font-family: 'DM Serif Display', serif;
    font-size: 2.2rem;
    color: var(--accent);
    display: block;
    line-height: 1;
    margin-bottom: 6px;
  }
  .level-goal {
    font-size: 0.65rem;
    color: var(--muted);
    letter-spacing: 0.08em;
    text-transform: uppercase;
    line-height: 1.5;
  }

  .back-link {
    margin-top: 20px;
    font-size: 0.68rem;
    color: var(--muted);
    letter-spacing: 0.1em;
    text-transform: uppercase;
    cursor: pointer;
    background: none;
    border: none;
    font-family: 'DM Mono', monospace;
    transition: color 0.2s;
  }
  .back-link:hover { color: var(--accent); }

  /* â”€â”€ Game screen â”€â”€ */
  #staff-wrap {
    background: #f9f9f4;
    border-radius: 12px;
    padding: 16px 8px;
    margin-bottom: 20px;
    display: flex;
    flex-direction: column;
    align-items: center;
    position: relative;
    transition: background 0.25s;
    width: 100%;
    box-sizing: border-box;
  }
  #staff-wrap.correct { background: #effff2; }
  #staff-wrap.wrong   { background: #fff2f2; }
  #staff-svg { display: block; width: 100%; }
  #staff-svg svg { width: 100% !important; height: auto !important; display: block; }
  #note-name-label {
    font-size: 0.65rem;
    color: #8888aa;
    letter-spacing: 0.1em;
    margin-top: 4px;
  }

  .status-row {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 8px;
  }
  .mic-dot {
    width: 9px; height: 9px;
    border-radius: 50%;
    background: var(--muted);
    flex-shrink: 0;
    transition: background 0.2s, box-shadow 0.2s;
  }
  .mic-dot.active {
    background: var(--accent);
    box-shadow: 0 0 8px var(--accent);
    animation: blink 1.4s infinite;
  }
  .mic-dot.error { background: var(--red); }
  @keyframes blink { 0%,100%{opacity:1} 50%{opacity:0.35} }

  #status-text { font-size: 0.72rem; color: var(--muted); letter-spacing: 0.04em; flex: 1; }
  #detected-note { font-size: 0.82rem; color: var(--accent2); min-width: 56px; text-align: right; }

  .conf-bar-wrap {
    height: 2px; background: var(--border);
    border-radius: 2px; margin-bottom: 18px; overflow: hidden;
  }
  .conf-bar {
    height: 100%; width: 0%;
    background: linear-gradient(90deg, var(--accent2), var(--accent));
    border-radius: 2px; transition: width 0.08s;
  }

  #feedback {
    text-align: center;
    font-family: 'DM Serif Display', serif;
    font-size: 1.6rem;
    height: 40px;
    margin-bottom: 18px;
    letter-spacing: -0.01em;
    transition: color 0.2s;
  }
  #feedback.correct { color: var(--accent); }
  #feedback.wrong   { color: var(--red); }

  /* Score / goal row */
  .score-row { display: flex; justify-content: space-between; gap: 10px; margin-bottom: 18px; }
  .score-box {
    flex: 1;
    background: var(--surface2);
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 12px 8px;
    text-align: center;
  }
  .score-val { font-size: 1.4rem; font-weight: 500; color: var(--text); display: block; }
  .score-val.green { color: var(--accent); }
  .score-val.red   { color: var(--red); }
  .score-label { font-size: 0.6rem; color: var(--muted); letter-spacing: 0.12em; text-transform: uppercase; margin-top: 2px; display: block; }

  /* Timer bar (level 4) */
  #timer-wrap { margin-bottom: 14px; display: none; }
  #timer-label { font-size: 0.65rem; color: var(--muted); letter-spacing: 0.1em; text-transform: uppercase; margin-bottom: 5px; }
  #timer-bar-bg { height: 6px; background: var(--border); border-radius: 3px; overflow: hidden; }
  #timer-bar { height: 100%; width: 100%; background: linear-gradient(90deg, var(--accent2), var(--accent)); border-radius: 3px; transition: width 0.1s linear; }
  #timer-bar.urgent { background: linear-gradient(90deg, var(--red), #ff9966); }

  /* â”€â”€ End screens â”€â”€ */
  .end-icon { font-size: 3.5rem; margin-bottom: 12px; }
  .end-title {
    font-family: 'DM Serif Display', serif;
    font-size: 1.9rem;
    letter-spacing: -0.02em;
    margin-bottom: 10px;
    text-align: center;
  }
  .end-title.win  { color: var(--accent); }
  .end-title.lose { color: var(--red); }
  .end-sub { font-size: 0.75rem; color: var(--muted); letter-spacing: 0.06em; margin-bottom: 28px; text-align: center; line-height: 1.7; }
</style>
</head>
<body>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â• HOME SCREEN â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div id="screen-home" class="screen active">
  <h1 class="page-title">Treble Clef Note Reading Game</h1>

  <div class="card">
    <div class="home-buttons">
      <button class="btn btn-primary mode-btn" onclick="goLevelSelect('spaces')">
        <span class="btn-title">Treble Clef Spaces</span>
        
      </button>
      <button class="btn btn-primary mode-btn" onclick="goLevelSelect('lines')">
        <span class="btn-title">Treble Clef Lines</span>
        
      </button>
    </div>
  </div>
</div>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â• LEVEL SELECT SCREEN â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div id="screen-levels" class="screen">
  <h1 class="page-title" id="level-screen-title">Spaces</h1>
  <p class="page-sub" id="level-screen-sub">Choose a level</p>
  <div class="card">
    <div class="level-grid">
      <div class="level-card" onclick="startGame(1)">
        <span class="level-num">1</span>
        <span class="level-goal">5 correct<br>in a row</span>
      </div>
      <div class="level-card" onclick="startGame(2)">
        <span class="level-num">2</span>
        <span class="level-goal">10 correct<br>in a row</span>
      </div>
      <div class="level-card" onclick="startGame(3)">
        <span class="level-num">3</span>
        <span class="level-goal">20 correct<br>in a row</span>
      </div>
      <div class="level-card" onclick="startGame(4)">
        <span class="level-num">4</span>
        <span class="level-goal">20 correct<br>under 40 sec</span>
      </div>
    </div>
  </div>
  <button class="back-link" onclick="goHome()">â† Back</button>
</div>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â• GAME SCREEN â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div id="screen-game" class="screen">
  <h1 class="page-title" id="game-title">Level <span id="game-level-num">1</span></h1>
  <p class="page-sub" id="game-goal-sub"></p>
  <div class="card">
    <div id="staff-wrap">
      <div id="staff-svg"></div>

    </div>

    <div class="status-row">
      <div class="mic-dot" id="mic-dot"></div>
      <span id="status-text">Startingâ€¦</span>
      <span id="detected-note">â€”</span>
    </div>
    <div class="conf-bar-wrap"><div class="conf-bar" id="conf-bar"></div></div>

    <div id="feedback">&nbsp;</div>

    <div id="timer-wrap">
      <div id="timer-label">Time remaining â€” <span id="timer-secs">30</span>s</div>
      <div id="timer-bar-bg"><div id="timer-bar"></div></div>
    </div>

    <div class="score-row">
      <div class="score-box">
        <span class="score-val green" id="sc-correct">0</span>
        <span class="score-label" id="sc-correct-label">Correct</span>
      </div>
      <div class="score-box">
        <span class="score-val" id="sc-streak">0</span>
        <span class="score-label" id="sc-streak-label">Streak</span>
      </div>
      <div class="score-box">
        <span class="score-val red" id="sc-wrong">0</span>
        <span class="score-label">Wrong</span>
      </div>
    </div>

    <button class="btn btn-secondary" onclick="quitGame()">Quit Level</button>
  </div>
</div>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â• WIN SCREEN â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div id="screen-win" class="screen">
  <div class="card" style="text-align:center">
    <div class="end-icon">ğŸ‰</div>
    <div class="end-title win" id="win-title">Congratulations!</div>
    <div class="end-sub" id="win-sub"></div>
    <button class="btn btn-primary" onclick="goLevelSelect(currentMode)">Play Another Level</button>
    <button class="btn btn-secondary btn-gap" onclick="goHome()">Home</button>
  </div>
</div>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â• LOSE SCREEN â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div id="screen-lose" class="screen">
  <div class="card" style="text-align:center">
    <div class="end-icon">ğŸ˜”</div>
    <div class="end-title lose">Not quite!</div>
    <div class="end-sub" id="lose-sub"></div>
    <button class="btn btn-primary" onclick="retryGame()">Try Again</button>
    <button class="btn btn-secondary btn-gap" onclick="goLevelSelect(currentMode)">Choose Level</button>
    <button class="btn btn-secondary btn-gap" onclick="goHome()">Home</button>
  </div>
</div>

<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// NOTE POOLS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const SPACES_NOTES = [
  { vex:'f/4', name:'F4', midi:65, acc:null },
  { vex:'a/4', name:'A4', midi:69, acc:null },
  { vex:'c/5', name:'C5', midi:72, acc:null },
  { vex:'e/5', name:'E5', midi:76, acc:null },
];
const LINES_NOTES = [
  { vex:'e/4', name:'E4', midi:64, acc:null },
  { vex:'g/4', name:'G4', midi:67, acc:null },
  { vex:'b/4', name:'B4', midi:71, acc:null },
  { vex:'d/5', name:'D5', midi:74, acc:null },
  { vex:'f/5', name:'F5', midi:77, acc:null },
];

// Level definitions: { streakGoal, totalGoal, timeLimit (seconds, 0=none) }
const LEVELS = [
  null, // index 0 unused
  { streakGoal: 5,  totalGoal: 0,  timeLimit: 0  }, // Level 1
  { streakGoal: 10, totalGoal: 0,  timeLimit: 0  }, // Level 2
  { streakGoal: 20, totalGoal: 0,  timeLimit: 0  }, // Level 3
  { streakGoal: 0,  totalGoal: 20, timeLimit: 40 }, // Level 4
];

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// VexFlow
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const VF = (typeof Vex !== "undefined" && Vex.Flow)
  ? Vex.Flow
  : (typeof VexFlow !== "undefined" ? VexFlow : null);

function renderNote(noteObj) {
  const container = document.getElementById('staff-svg');
  container.innerHTML = '';

  // Always render VexFlow at a fixed large internal canvas (avoids any layout-dependent clipping)
  const RENDER_W = 400;
  const RENDER_H = 160;
  const renderer = new VF.Renderer(container, VF.Renderer.Backends.SVG);
  renderer.resize(RENDER_W, RENDER_H);
  const ctx = renderer.getContext();

  const stave = new VF.Stave(10, 20, RENDER_W - 20);
  stave.addClef('treble');
  stave.setContext(ctx).draw();

  const sn = new VF.StaveNote({ clef:'treble', keys:[noteObj.vex], duration:'q' });
  if (noteObj.acc === '#') sn.addAccidental(0, new VF.Accidental('#'));
  else if (noteObj.acc === 'b') sn.addAccidental(0, new VF.Accidental('b'));
  const voice = new VF.Voice({ num_beats:1, beat_value:4 });
  voice.setStrict(false);
  voice.addTickables([sn]);
  new VF.Formatter().joinVoices([voice]).format([voice], RENDER_W - 100);
  voice.draw(ctx, stave);

  // VexFlow 3 sets hard pixel width/height on the SVG element.
  // Override with viewBox + CSS so it scales to fit any screen width,
  // and height:auto so the browser derives the correct height from the aspect ratio.
  const svgEl = container.querySelector('svg');
  if (svgEl) {
    svgEl.setAttribute('viewBox', '0 0 ' + RENDER_W + ' ' + RENDER_H);
    svgEl.setAttribute('preserveAspectRatio', 'xMidYMid meet');
    // Remove both the attribute AND the inline style VexFlow may have set
    svgEl.removeAttribute('width');
    svgEl.removeAttribute('height');
    svgEl.style.cssText = 'width:100% !important; height:auto !important; display:block;';
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Pitch detection
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â”€â”€ Inline McLeod Pitch Method (MPM) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Based on McLeod & Wyvill (2005). No external dependency.
// Much more accurate than autocorrelation for piano/harmonic-rich instruments.

function detectPitch(buffer, sampleRate) {
  const N = buffer.length;

  // RMS silence check
  let rms = 0;
  for (let i = 0; i < N; i++) rms += buffer[i] * buffer[i];
  rms = Math.sqrt(rms / N);
  if (rms < 0.003) return { freq: -1, clarity: 0 };

  // Step 1: Normalised Square Difference Function (NSDF)
  // nsdf[tau] = 2 * acf[tau] / (r[0] + r[tau])  where r[tau] = sum(x^2 shifts)
  const nsdf = new Float32Array(N);
  let rTau = 0, r0 = 0;
  for (let i = 0; i < N; i++) r0 += buffer[i] * buffer[i];
  rTau = r0;
  // acf via direct computation for the lags we need (up to N/2)
  // Use a running update for efficiency
  const acf = new Float32Array(N);
  for (let tau = 0; tau < N / 2; tau++) {
    let sum = 0;
    for (let i = 0; i < N - tau; i++) sum += buffer[i] * buffer[i + tau];
    acf[tau] = sum;
  }
  // m'(tau) = sum(x[i]^2) + sum(x[i+tau]^2) for i=0..N-tau-1
  for (let tau = 0; tau < N / 2; tau++) {
    let mTau = 0;
    for (let i = 0; i < N - tau; i++) mTau += buffer[i] * buffer[i] + buffer[i + tau] * buffer[i + tau];
    nsdf[tau] = mTau > 0 ? (2 * acf[tau]) / mTau : 0;
  }

  // Step 2: Find all positive-to-negative zero crossings after the first,
  // pick the highest peak between each pair as a "key maximum"
  const keyMaxima = [];
  let posStart = -1;
  let peakVal = -Infinity, peakPos = -1;

  for (let tau = 1; tau < N / 2; tau++) {
    if (nsdf[tau - 1] <= 0 && nsdf[tau] > 0) {
      posStart = tau;
      peakVal = -Infinity;
      peakPos = -1;
    }
    if (posStart >= 0 && nsdf[tau] > peakVal) {
      peakVal = nsdf[tau];
      peakPos = tau;
    }
    if (posStart >= 0 && nsdf[tau - 1] >= 0 && nsdf[tau] < 0 && peakPos > 0) {
      keyMaxima.push({ pos: peakPos, val: peakVal });
      posStart = -1;
    }
  }

  if (keyMaxima.length === 0) return { freq: -1, clarity: 0 };

  // Step 3: Pick the first key maximum above the threshold k*globalMax
  let globalMax = -Infinity;
  for (let i = 0; i < keyMaxima.length; i++) { if (keyMaxima[i].val > globalMax) globalMax = keyMaxima[i].val; }
  const k = 0.8; // MPM threshold â€” lower = more sensitive, higher = more selective
  let chosen = null;
  for (const m of keyMaxima) {
    if (m.val >= k * globalMax) { chosen = m; break; }
  }
  if (!chosen) chosen = keyMaxima[0];

  // Step 4: Parabolic interpolation for sub-sample accuracy
  const tau = chosen.pos;
  const y1 = (tau - 1 >= 0) ? nsdf[tau - 1] : nsdf[tau];
  const y2 = nsdf[tau];
  const y3 = (tau + 1 < nsdf.length) ? nsdf[tau + 1] : nsdf[tau];
  const denom = 2 * (2 * y2 - y1 - y3);
  const refinedTau = denom !== 0 ? tau + (y3 - y1) / denom : tau;

  const freq = sampleRate / refinedTau;
  const clarity = Math.max(0, Math.min(1, chosen.val));

  return { freq, clarity };
}

function initPitchDetector() { /* no-op: MPM is inline, nothing to init */ }
function freqToMidi(freq) { return Math.round(12 * Math.log2(freq / 440) + 69); }
function midiToName(midi) {
  const names = ['C','Câ™¯','D','Dâ™¯','E','F','Fâ™¯','G','Gâ™¯','A','Aâ™¯','B'];
  return names[midi % 12] + (Math.floor(midi / 12) - 1);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// App state
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let currentMode = 'spaces';   // 'spaces' | 'lines'
let currentLevel = 1;
let notePool = [];
let currentNote = null;

// Game counters
let correctCount = 0;
let wrongCount = 0;
let streakCount = 0;

// Audio
let listening = false;
let audioCtx = null, analyser = null, micStream = null, rafId = null;
let cooldown = false, lastMidi = -1, stableCount = 0;
const STABLE_NEEDED = 3;

// Timer (level 4)
let timerInterval = null;
let timerSecsLeft = 30;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Screen navigation
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function showScreen(id) {
  document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
  document.getElementById(id).classList.add('active');
}

function goHome() {
  stopAudio();
  stopTimer();
  showScreen('screen-home');
}

function goLevelSelect(mode) {
  stopAudio();
  stopTimer();
  currentMode = mode;
  const isSpaces = mode === 'spaces';
  document.getElementById('level-screen-title').innerHTML =
    'Treble Clef <span style="color:var(--accent)">' + (isSpaces ? 'Spaces' : 'Lines') + '</span>';
  document.getElementById('level-screen-sub').textContent =
    '';
  showScreen('screen-levels');
}

async function startGame(level) {
  currentLevel = level;
  notePool = currentMode === 'spaces' ? SPACES_NOTES : LINES_NOTES;
  correctCount = 0; wrongCount = 0; streakCount = 0;
  currentNote = null;
  cooldown = false; lastMidi = -1; stableCount = 0;

  // Update game screen labels
  document.getElementById('game-level-num').textContent = level;
  const def = LEVELS[level];
  let goalText = '';
  if (level === 4) goalText = 'Get 20 correct in 40 seconds';
  else if (level === 1) goalText = 'Get 5 correct in a row';
  else if (level === 2) goalText = 'Get 10 correct in a row';
  else if (level === 3) goalText = 'Get 20 correct in a row';
  document.getElementById('game-goal-sub').textContent = goalText;

  // Streak label changes based on mode
  if (def.streakGoal > 0) {
    document.getElementById('sc-streak-label').textContent = `Streak / ${def.streakGoal}`;
  } else {
    document.getElementById('sc-streak-label').textContent = 'Streak';
    document.getElementById('sc-correct-label').textContent = `Correct / ${def.totalGoal}`;
  }

  updateScoreDisplay();
  document.getElementById('feedback').innerHTML = '&nbsp;';
  document.getElementById('feedback').className = '';

  // Timer bar
  const timerWrap = document.getElementById('timer-wrap');
  if (def.timeLimit > 0) {
    timerWrap.style.display = 'block';
    timerSecsLeft = def.timeLimit;
    document.getElementById('timer-secs').textContent = timerSecsLeft;
    document.getElementById('timer-bar').style.width = '100%';
    document.getElementById('timer-bar').classList.remove('urgent');
  } else {
    timerWrap.style.display = 'none';
  }

  showScreen('screen-game');

  // Start mic
  await initAudio();
  if (!listening) return; // mic failed â€” stay on screen but don't proceed

  pickAndShowNote();
  audioLoop();

  // Start countdown for level 4
  if (def.timeLimit > 0) {
    startTimer(def.timeLimit);
  }
}

function retryGame() { startGame(currentLevel); }

function quitGame() {
  stopAudio();
  stopTimer();
  goLevelSelect(currentMode);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Audio init / teardown
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function initAudio() {
  stopAudio();
  document.getElementById('mic-dot').className = 'mic-dot';
  document.getElementById('status-text').textContent = 'Requesting microphoneâ€¦';

  try {
    micStream = await navigator.mediaDevices.getUserMedia({
      audio: { echoCancellation: false, noiseSuppression: false, autoGainControl: false }
    });
  } catch(e) {
    document.getElementById('status-text').textContent = 'Mic access denied â€” please allow microphone.';
    document.getElementById('mic-dot').className = 'mic-dot error';
    return;
  }

  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  analyser = audioCtx.createAnalyser();
  analyser.fftSize = 4096;
  analyser.smoothingTimeConstant = 0.5;
  audioCtx.createMediaStreamSource(micStream).connect(analyser);
  initPitchDetector();
  listening = true;
  document.getElementById('mic-dot').className = 'mic-dot active';
  document.getElementById('status-text').textContent = 'Listening â€” play the note shown';
}

function stopAudio() {
  listening = false;
  cancelAnimationFrame(rafId);
  if (micStream) { micStream.getTracks().forEach(t => t.stop()); micStream = null; }
  if (audioCtx)  { audioCtx.close(); audioCtx = null; }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Timer (level 4)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function startTimer(secs) {
  stopTimer();
  timerSecsLeft = secs;
  const bar = document.getElementById('timer-bar');
  const label = document.getElementById('timer-secs');
  const total = secs;

  timerInterval = setInterval(() => {
    timerSecsLeft--;
    label.textContent = timerSecsLeft;
    bar.style.width = ((timerSecsLeft / total) * 100) + '%';
    if (timerSecsLeft <= 10) bar.classList.add('urgent');
    if (timerSecsLeft <= 0) {
      stopTimer();
      endLevel(false);
    }
  }, 1000);
}

function stopTimer() {
  if (timerInterval) { clearInterval(timerInterval); timerInterval = null; }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Game logic
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function pickAndShowNote() {
  let n, tries = 0;
  do {
    n = notePool[Math.floor(Math.random() * notePool.length)];
    tries++;
  } while (currentNote && n.midi === currentNote.midi && tries < 20);
  currentNote = n;
  renderNote(currentNote);
  document.getElementById('feedback').innerHTML = '&nbsp;';
  document.getElementById('feedback').className = '';
  lastMidi = -1; stableCount = 0; cooldown = false;
}

function updateScoreDisplay() {
  document.getElementById('sc-correct').textContent = correctCount;
  document.getElementById('sc-streak').textContent = streakCount;
  document.getElementById('sc-wrong').textContent = wrongCount;
}

function flash(text, cls) {
  const fb = document.getElementById('feedback');
  fb.textContent = text;
  fb.className = cls;
  const wrap = document.getElementById('staff-wrap');
  wrap.classList.add(cls);
  setTimeout(() => wrap.classList.remove(cls), 450);
}

function checkWinCondition() {
  const def = LEVELS[currentLevel];
  if (def.streakGoal > 0 && streakCount >= def.streakGoal) return true;
  if (def.totalGoal > 0 && correctCount >= def.totalGoal) return true;
  return false;
}

function endLevel(won) {
  stopAudio();
  stopTimer();
  if (won) {
    document.getElementById('win-title').textContent = `Congratulations, you completed Level ${currentLevel}!`;
    const def = LEVELS[currentLevel];
    let detail = '';
    if (currentLevel === 4) detail = `20 notes correct in ${40 - timerSecsLeft} seconds with ${wrongCount} mistake${wrongCount !== 1 ? 's' : ''}.`;
    else detail = `You hit a streak of ${def.streakGoal} with ${wrongCount} mistake${wrongCount !== 1 ? 's' : ''}.`;
    document.getElementById('win-sub').textContent = detail;
    showScreen('screen-win');
  } else {
    const def = LEVELS[currentLevel];
    let detail = '';
    if (currentLevel === 4) detail = `You got ${correctCount} / 20 correct before time ran out.`;
    else detail = `Your best streak was ${streakCount}. Goal: ${def.streakGoal} in a row.`;
    document.getElementById('lose-sub').textContent = detail;
    showScreen('screen-lose');
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Audio loop
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function audioLoop() {
  if (!listening) return;
  rafId = requestAnimationFrame(audioLoop);

  // Retry Pitchy init if it wasn't ready when audio started


  const buf = new Float32Array(analyser.fftSize);
  analyser.getFloatTimeDomainData(buf);
  const { freq, clarity } = detectPitch(buf, audioCtx.sampleRate);
  const confBar = document.getElementById('conf-bar');

  if (freq < 20 || clarity < 0.6) {
    document.getElementById('detected-note').textContent = 'â€”';
    confBar.style.width = '0%';
    lastMidi = -1; stableCount = 0;
    return;
  }

  const midi = freqToMidi(freq);
  document.getElementById('detected-note').textContent = midiToName(midi);

  confBar.style.width = (clarity * 100).toFixed(0) + '%';

  if (clarity < 0.6) { lastMidi = -1; stableCount = 0; return; }
  if (midi === lastMidi) stableCount++;
  else { lastMidi = midi; stableCount = 1; }

  if (stableCount >= STABLE_NEEDED && !cooldown && currentNote) {
    cooldown = true;
    stableCount = 0;

    // Match on pitch class only (same note name, any octave)
    // This handles the common case where autocorrelation detects an octave harmonic
    // instead of the true fundamental, without allowing adjacent wrong notes through.
    const pitchMatch = (midi % 12 === currentNote.midi % 12);
    if (pitchMatch) {
      correctCount++; streakCount++;
      updateScoreDisplay();
      flash('âœ“ Correct!', 'correct');

      if (checkWinCondition()) {
        setTimeout(() => endLevel(true), 600);
      } else {
        setTimeout(pickAndShowNote, 700);
      }
    } else {
      wrongCount++;
      const def = LEVELS[currentLevel];
      // For streak-based levels, a wrong answer resets streak
      if (def.streakGoal > 0) streakCount = 0;
      updateScoreDisplay();
      const got = midiToName(midi);
      flash(`âœ— That was ${got}`, 'wrong');
      setTimeout(() => { cooldown = false; }, 1100);
    }
  }
}
// Re-render on window resize so notation stays within bounds
window.addEventListener('resize', function() {
  if (currentNote) renderNote(currentNote);
});
</script>
</body>
</html>
